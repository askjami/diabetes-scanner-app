<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Diabetic Label Checker — Camera + OCR</title>
<!-- Tesseract.js (client-side OCR) -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
<style>
:root{
--bg:#0f1724; --card:#0b1220; --accent:#22c1c3; --muted:#9aa7b2; --ok:#16a34a; --warn:#f59e0b; --bad:#ef4444;
--glass: rgba(255,255,255,0.03);
font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
color: #e6eef6;
}
html,body{height:100%; margin:0; background:linear-gradient(180deg,#07101a 0%, #091827 100%); }
.wrap{max-width:1100px; margin:20px auto; padding:18px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); box-shadow: 0 6px 30px rgba(2,6,23,0.6);}
header{display:flex; gap:12px; align-items:center; margin-bottom:12px;}
header h1{font-size:1.2rem; margin:0;}
.row{display:flex; gap:12px;}
.column{display:flex; flex-direction:column; gap:12px;}
.left, .right{background:var(--card); padding:12px; border-radius:10px;}
.left{flex:1; min-width:320px;}
.right{width:420px; min-width:300px;}
video{width:100%; border-radius:8px; background:#000; height:300px; object-fit:cover;}
canvas{display:none;}
.controls{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;}
button{background:linear-gradient(180deg,var(--glass), rgba(255,255,255,0.02)); border:1px solid rgba(255,255,255,0.03); color:var(--accent); padding:8px 10px; border-radius:8px; cursor:pointer;}
button.positive{background:linear-gradient(180deg, rgba(20,120,90,0.2), rgba(20,120,90,0.08)); color:var(--ok); border-color:rgba(20,120,90,0.12);}
button.warn{color:var(--warn);}
button.danger{color:var(--bad);}
input[type=file]{display:none;}
.progress{height:10px;background:rgba(255,255,255,0.04);border-radius:6px;overflow:hidden;}
.progress > div{height:100%; width:0%; background:linear-gradient(90deg,var(--accent), #7be3e2); transition:width .2s;}
.result{white-space:pre-wrap; font-size:0.95rem; color:#dff3f3; max-height:300px; overflow:auto; padding:8px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));}
.match{display:inline-block; padding:2px 6px; border-radius:6px; margin:3px; font-size:0.85rem;}
.match.high{background:rgba(239,68,68,0.12); color:var(--bad); border:1px solid rgba(239,68,68,0.16);}
.match.caution{background:rgba(245,158,11,0.08); color:var(--warn); border:1px solid rgba(245,158,11,0.12);}
.match.low{background:rgba(16,185,129,0.06); color:var(--ok); border:1px solid rgba(16,185,129,0.08);}
.tags{display:flex; flex-wrap:wrap; gap:8px; margin-top:6px;}
.small{font-size:0.85rem; color:var(--muted);}
.history{max-height:220px; overflow:auto; padding:6px; border-radius:6px; background:rgba(255,255,255,0.01);}
.history-item{padding:8px; border-radius:6px; margin-bottom:8px; background:rgba(255,255,255,0.01); border:1px solid rgba(255,255,255,0.02);}
footer{margin-top:12px; font-size:0.82rem; color:var(--muted);}
@media (max-width:980px){
.row{flex-direction:column;}
.right{width:100%;}
}
</style>
</head>
<body>
<div class="wrap">
<header>
<img src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='36' height='36' viewBox='0 0 24 24'><path fill='%2322c1c3' d='M12 2a2 2 0 0 1 2 2v2h4a1 1 0 0 1 1 1v11a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V7a1 1 0 0 1 1-1h4V4a2 2 0 0 1 2-2z'/></svg>" alt="logo" />
<div>
<h1>Diabetic Label Checker</h1>
<div class="small">Use your camera to scan product labels — scans run locally in your browser.</div>
</div>
</header>

<div class="row">
<div class="left column">
<div style="display:flex; gap:10px; align-items:flex-start;">
<div style="flex:1;">
<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>
</div>
<div style="width:220px;">
<div class="small">Camera controls</div>
<div class="controls">
<button id="startCamera" class="positive">Start Camera</button>
<button id="stopCamera" class="danger">Stop</button>
</div>
<div class="controls">
<button id="capture" title="Capture frame">Capture</button>
<label for="uploadInput" style="display:inline-block">
<button id="uploadBtn">Upload Image</button>
</label>
<input id="uploadInput" type="file" accept="image/*">
</div>

<div style="margin-top:8px">
<button id="toggleTorch">Toggle Torch (if supported)</button>
<button id="analyzeBtn" class="positive">Analyze OCR</button>
</div>

<div style="margin-top:10px">
<div class="small">OCR progress</div>
<div class="progress" aria-hidden><div id="progressBar"></div></div>
<div id="status" class="small">Idle</div>
</div>

<div style="margin-top:10px">
<div class="small">Recent scans</div>
<div class="history" id="history"></div>
<div style="display:flex; gap:8px; margin-top:6px;">
<button id="exportCSV">Export CSV</button>
<button id="clearHistory" class="warn">Clear</button>
</div>
</div>

</div>
</div>
</div>

<div class="right column">
<div>
<div class="small">OCR text</div>
<div id="ocrText" class="result" aria-live="polite">No text recognized yet.</div>
<div style="display:flex; justify-content:space-between; align-items:center; margin-top:6px;">
<div class="small">Matches found</div>
<div class="small" id="summaryLabel">—</div>
</div>
<div id="matches" class="tags" style="margin-top:8px;"></div>
</div>

<div style="margin-top:12px;">
<div class="small">Interpretation & advice</div>
<div id="interpretation" class="result">No analysis yet.</div>
</div>

<div style="margin-top:12px;">
<div class="small">Quick tips</div>
<div class="result small">Look for "No added sugar", check "Total Carbohydrate" grams per serving, avoid products with high grams per serving unless accounted for in your meal plan. This tool is informational only.</div>
</div>

</div>
</div>

<footer>
<div>Built with Tesseract.js · Runs locally in your browser · Not medical advice.</div>
</footer>
</div>

<script>
(async function(){
// ----------------------------
// Ingredient dictionaries
// ----------------------------
const INGREDIENT_RULES = [
{k: 'sugars', type: 'high', examples: ['sugar','cane sugar','sucrose','fructose','glucose','high fructose corn syrup','hfcs','corn syrup','invert sugar','maltose','malt syrup','malt extract','molasses','honey','concentrated fruit juice','fruit juice concentrate','dextrose','galactose','lactose']},
{k: 'starches & high-carb', type: 'caution', examples: ['maltodextrin','dextrin','modified starch','starch','wheat flour','rice flour','potato starch','tapioca','corn syrup solids','malt','maltodextrin','dextrin']},
{k: 'sugar substitutes (low-cal)', type: 'low', examples: ['aspartame','sucralose','saccharin','acesulfame','acesulfame potassium','stevia','rebaudioside','erythritol','xylitol','sorbitol','monk fruit','allulose','neotame','advantame']},
{k: 'sugar alcohols', type: 'caution', examples: ['sorbitol','mannitol','xylitol','erythritol','maltitol','isomalt']},
{k: 'natural sweeteners (mixed)', type: 'caution', examples: ['agave','brown sugar','coconut sugar','maple syrup','dates','date paste','fruit concentrate']},
{k: 'hidden names', type: 'high', examples: ['barley malt','corn sweetener','fruit juice concentrate','corn syrup solids','evaporated cane juice','demerara','turbinado']},
];

// Threshold for "high carb" per serving (grams)
const HIGH_CARB_THRESHOLD = 15; // grams per serving considered high (adjustable)
const CAUTION_CARB_THRESHOLD = 7;

// ----------------------------
// Elements
// ----------------------------
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const startCameraBtn = document.getElementById('startCamera');
const stopCameraBtn = document.getElementById('stopCamera');
const captureBtn = document.getElementById('capture');
const uploadInput = document.getElementById('uploadInput');
const uploadBtn = document.getElementById('uploadBtn');
const analyzeBtn = document.getElementById('analyzeBtn');
const progressBar = document.getElementById('progressBar');
const status = document.getElementById('status');
const ocrTextEl = document.getElementById('ocrText');
const matchesEl = document.getElementById('matches');
const interpretationEl = document.getElementById('interpretation');
const summaryLabel = document.getElementById('summaryLabel');
const historyEl = document.getElementById('history');
const exportCSVBtn = document.getElementById('exportCSV');
const clearHistoryBtn = document.getElementById('clearHistory');
const toggleTorchBtn = document.getElementById('toggleTorch');

let stream = null;
let currentImageBlob = null;
let lastOCRText = '';
let history = JSON.parse(localStorage.getItem('scanHistory')||'[]');
let trackForTorch = null;
renderHistory();

// ----------------------------
// Camera controls
// ----------------------------
startCameraBtn.addEventListener('click', async ()=>{
try{
if (stream){ stopCamera(); }
const constraints = {
audio:false,
video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }
};
stream = await navigator.mediaDevices.getUserMedia(constraints);
video.srcObject = stream;
// Torch support
const [track] = stream.getVideoTracks() || [];
trackForTorch = track;
status.textContent = 'Camera started';
}catch(err){
console.error(err);
status.textContent = 'Camera error: ' + (err.message || err.name);
alert('Could not start camera: ' + (err.message || err.name) + '\nTry using Upload Image instead.');
}
});

stopCameraBtn.addEventListener('click', stopCamera);
function stopCamera(){
if (stream){
stream.getTracks().forEach(t=>t.stop());
stream = null;
video.srcObject = null;
status.textContent = 'Camera stopped';
trackForTorch = null;
}
}

// Torch toggle
toggleTorchBtn.addEventListener('click', async ()=>{
if (!trackForTorch) {
alert('Torch not available. Start the camera first and ensure your device supports torch control.');
return;
}
try{
const cap = trackForTorch.getCapabilities();
if (!cap.torch) { alert('Torch not supported on this device/browser.'); return; }
const settings = trackForTorch.getSettings();
const current = settings.torch === true;
await trackForTorch.applyConstraints({ advanced: [{ torch: !current }] });
status.textContent = 'Torch: ' + (!current ? 'on' : 'off');
}catch(err){
console.warn(err);
alert('Torch control failed: ' + err.message);
}
});

// ----------------------------
// Capture or upload image
// ----------------------------
captureBtn.addEventListener('click', ()=>{
if (!video || !stream){
alert('Start the camera first or use Upload Image.');
return;
}
const w = video.videoWidth;
const h = video.videoHeight;
canvas.width = w;
canvas.height = h;
const ctx = canvas.getContext('2d');
ctx.drawImage(video,0,0,w,h);
canvas.toBlob(async (blob) => {
currentImageBlob = blob;
status.textContent = 'Captured image';
// show preview in OCR text area as base64 small preview? We will run OCR when user hits Analyze
const url = URL.createObjectURL(blob);
ocrTextEl.innerHTML = 'Image captured. Click "Analyze OCR" to read label.<br><small class="small">Preview:</small><br><img src="'+url+'" style="max-width:100%; border-radius:6px; margin-top:6px;" />';
}, 'image/jpeg', 0.95);
});

uploadInput.addEventListener('change', (e)=>{
const f = e.target.files && e.target.files[0];
if (!f) return;
currentImageBlob = f;
const url = URL.createObjectURL(f);
ocrTextEl.innerHTML = 'Image loaded. Click "Analyze OCR" to read label.<br><small class="small">Preview:</small><br><img src="'+url+'" style="max-width:100%; border-radius:6px; margin-top:6px;" />';
status.textContent = 'Image loaded';
uploadInput.value = ''; // reset
});

// ----------------------------
// OCR & Analysis
// ----------------------------
analyzeBtn.addEventListener('click', async ()=>{
if (!currentImageBlob){
alert('No image available. Capture with camera or upload an image first.');
return;
}
try{
progressBar.style.width = '0%';
status.textContent = 'Starting OCR...';
matchesEl.innerHTML = '';
interpretationEl.textContent = '';
summaryLabel.textContent = 'Scanning...';

// run Tesseract worker
const worker = Tesseract.createWorker({
logger: m => {
if (m.status === 'recognizing text' && m.progress) {
const pct = Math.round(m.progress * 100);
progressBar.style.width = pct + '%';
status.textContent = `OCR: ${pct}%`;
} else if (m.status) {
status.textContent = m.status;
}
}
});

await worker.load();
await worker.loadLanguage('eng');
await worker.initialize('eng');
const { data: { text } } = await worker.recognize(currentImageBlob);
await worker.terminate();

lastOCRText = text.trim();
ocrTextEl.textContent = lastOCRText || 'No text recognized.';
progressBar.style.width = '100%';
status.textContent = 'OCR complete';

// analyze recognized text
const analysis = analyzeText(lastOCRText);
renderAnalysis(analysis);

// save to history
saveToHistory(analysis);

}catch(err){
console.error(err);
status.textContent = 'OCR error';
alert('OCR failed: ' + (err.message || err.name));
}
});

// ----------------------------
// Text analysis functions
// ----------------------------
function analyzeText(text){
const lc = text.toLowerCase();
const tokens = lc.split(/[\n,.;:()]+/).map(s=>s.trim()).filter(Boolean);
const matches = [];
// find ingredient matches
for (const rule of INGREDIENT_RULES){
for (const ex of rule.examples){
const rx = new RegExp('\\b' + escapeRegex(ex) + '\\b','i');
if (rx.test(lc)){
matches.push({word: ex, type: rule.type, category: rule.k});
}
}
}
// Additional pattern checks
// numeric grams for Total Carbohydrate / Sugars
const grams = [];
// find lines like "Total Carbohydrate 12 g" or "Total carbohydrate 12g"
const carbRegex = /total\s+carbohydrate[s]?\s*[:\-]?\s*([0-9]+(?:\.[0-9]+)?)\s*g/i;
const carbMatch = lc.match(carbRegex);
if (carbMatch) grams.push({label:'Total Carbohydrate', grams: parseFloat(carbMatch[1])});

// Sugars
const sugarRegex = /sugar[s]?\s*[:\-]?\s*([0-9]+(?:\.[0-9]+)?)\s*g/i;
const sugarMatch = lc.match(sugarRegex);
if (sugarMatch) grams.push({label:'Sugars', grams: parseFloat(sugarMatch[1])});

// Generic any number + g near words carb / carbs / sugars
const genericRegex = /([0-9]+(?:\.[0-9]+)?)\s*g/ig;
let g;
while((g = genericRegex.exec(lc)) !== null){
// see context around it
const idx = g.index;
const snippet = lc.slice(Math.max(0, idx-30), Math.min(lc.length, idx+30));
if (/(carbohydrat|carb|sugar|sugars|total)/i.test(snippet)){
// only add if not duplicate
const val = parseFloat(g[1]);
if (!grams.find(x=>Math.abs(x.grams - val) < 0.001)) grams.push({label: snippet.replace(/\s+/g,' ').slice(0,30), grams: val});
}
}

// Evaluate risk level and generate highlights
let riskScore = 0;
const found = {high:[], caution:[], low:[]};
for (const m of matches){
if (m.type === 'high') { found.high.push(m.word); riskScore += 2; }
else if (m.type === 'caution') { found.caution.push(m.word); riskScore += 1; }
else if (m.type === 'low') { found.low.push(m.word); riskScore -= 1; }
}

// analyze grams
let carbWarnings = [];
for (const gobj of grams){
const gval = gobj.grams;
if (gval >= HIGH_CARB_THRESHOLD){
carbWarnings.push({label:gobj.label, grams:gval, severity:'high', message:`${gval} g per serving — considered HIGH for many people managing carbs.`});
riskScore += 3;
} else if (gval >= CAUTION_CARB_THRESHOLD){
carbWarnings.push({label:gobj.label, grams:gval, severity:'caution', message:`${gval} g per serving — moderate carbs; check portion size.`});
riskScore += 1;
} else {
carbWarnings.push({label:gobj.label, grams:gval, severity:'low', message:`${gval} g per serving — relatively low.`});
riskScore -= 1;
}
}

// final level
let level = 'Unknown';
if (riskScore >= 4) level = 'Not recommended / High risk';
else if (riskScore >= 1) level = 'Use with caution';
else if (riskScore <= -1) level = 'Likely okay (low sugar/carbs)';
else level = 'Mixed / inconclusive';

// extract product name heuristically: first non-empty line
const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
const productName = lines.length ? lines[0] : 'Unknown product';

// prepare details: highlight occurrences in original text (case-insensitive)
const highlights = [];
for (const h of found.high){
highlights.push({word:h, cls:'high'});
}
for (const h of found.caution){
highlights.push({word:h, cls:'caution'});
}
for (const h of found.low){
highlights.push({word:h, cls:'low'});
}

return {
productName,
rawText: text,
matchesFound: {found, grams, highlights},
carbWarnings,
riskScore,
level,
timestamp: new Date().toISOString()
};
}

function renderAnalysis(analysis){
// summary
summaryLabel.textContent = analysis.level;

// matches boxes
matchesEl.innerHTML = '';
const {found, highlights} = analysis.matchesFound;
const makeTag = (list, cls, title) => {
for (const w of list){
const el = document.createElement('span');
el.className = 'match ' + cls;
el.textContent = w;
el.title = title || '';
matchesEl.appendChild(el);
}
};
makeTag(found.high, 'high', 'High-risk sugar or hidden sugars');
makeTag(found.caution, 'caution', 'Caution: starch, sugar alcohols or mixed sweeteners');
makeTag(found.low, 'low', 'Low-cal sweetener / substitute');

// grams info
if (analysis.matchesFound.grams && analysis.matchesFound.grams.length){
for (const g of analysis.matchesFound.grams){
const el = document.createElement('span');
const cls = g.grams >= HIGH_CARB_THRESHOLD ? 'high' : (g.grams >= CAUTION_CARB_THRESHOLD ? 'caution' : 'low');
el.className = 'match ' + cls;
el.textContent = `${g.label}: ${g.grams} g`;
matchesEl.appendChild(el);
}
}

// interpretation section
const lines = [];
lines.push('Product: ' + analysis.productName);
lines.push('Assessment: ' + analysis.level);
lines.push('');
if (analysis.carbWarnings.length){
lines.push('Carb / sugar values found:');
for (const c of analysis.carbWarnings){
lines.push(` • ${c.label}: ${c.grams} g — ${c.message}`);
}
lines.push('');
}
if (analysis.matchesFound.found.high.length){
lines.push('High-risk ingredients (likely to raise blood glucose): ' + Array.from(new Set(analysis.matchesFound.found.high)).join(', '));
}
if (analysis.matchesFound.found.caution.length){
lines.push('Caution ingredients (may contribute carbs or have mixed effects): ' + Array.from(new Set(analysis.matchesFound.found.caution)).join(', '));
}
if (analysis.matchesFound.found.low.length){
lines.push('Sugar substitutes detected (low-calorie): ' + Array.from(new Set(analysis.matchesFound.found.low)).join(', '));
}
lines.push('');
lines.push('Advice:');
lines.push('- Check serving size and total carbohydrate per serving.');
lines.push('- If sugars or high grams of carbs are present, treat carefully in your carbohydrate budget.');
lines.push('- Sugar substitutes (e.g., sucralose, stevia) are low-calorie but check for mixed sweeteners or sugar alcohols which can affect digestion.');
lines.push('- When unsure, choose "No added sugar" or low-carb options and consult your healthcare team.');

interpretationEl.textContent = lines.join('\\n');

// highlight matches in OCR text (displayed area)
let displayHTML = escapeHtml(lastOCRText);
// order replacements by length descending to avoid partial overlaps
const replacers = [];
for (const h of analysis.matchesFound.high) replacers.push({word:h, cls:'high'});
for (const h of analysis.matchesFound.caution) replacers.push({word:h, cls:'caution'});
for (const h of analysis.matchesFound.low) replacers.push({word:h, cls:'low'});
replacers.sort((a,b)=>b.word.length - a.word.length);
for (const r of replacers){
const rx = new RegExp('('+escapeRegex(r.word)+')','ig');
displayHTML = displayHTML.replace(rx, `<span class="match ${r.cls}">$1</span>`);
}
ocrTextEl.innerHTML = displayHTML || 'No text recognized.';

}

// ----------------------------
// History
// ----------------------------
function saveToHistory(analysis){
const item = {
id: Date.now(),
name: analysis.productName,
level: analysis.level,
time: analysis.timestamp,
matches: {
high: Array.from(new Set(analysis.matchesFound.found.high)),
caution: Array.from(new Set(analysis.matchesFound.found.caution)),
low: Array.from(new Set(analysis.matchesFound.found.low)),
grams: analysis.matchesFound.grams || []
}
};
history.unshift(item);
// keep most recent 50
history = history.slice(0,50);
localStorage.setItem('scanHistory', JSON.stringify(history));
renderHistory();
}

function renderHistory(){
historyEl.innerHTML = '';
if (!history.length){ historyEl.innerHTML = '<div class="small">No scans yet</div>'; return; }
for (const h of history){
const outer = document.createElement('div');
outer.className = 'history-item';
outer.innerHTML = `<div style="display:flex; justify-content:space-between; gap:8px;">
<div><strong>${escapeHtml(h.name)}</strong><div class="small">${new Date(h.time).toLocaleString()}</div></div>
<div style="text-align:right"><div class="small">${escapeHtml(h.level)}</div></div>
</div>
<div class="small" style="margin-top:6px">Matches: ${escapeHtml((h.matches.high||[]).concat(h.matches.caution||[], h.matches.low||[]).slice(0,6).join(', ') || '—')}</div>
`;
historyEl.appendChild(outer);
}
}

clearHistoryBtn.addEventListener('click', ()=>{
if (!confirm('Clear saved scans?')) return;
history = [];
localStorage.removeItem('scanHistory');
renderHistory();
});

exportCSVBtn.addEventListener('click', ()=>{
if (!history.length){ alert('No history to export.'); return; }
const rows = [['Time','Product','Level','High matches','Caution matches','Low matches','Carb info']];
for (const h of history){
rows.push([
h.time,
h.name,
h.level,
h.matches.high.join('|'),
h.matches.caution.join('|'),
h.matches.low.join('|'),
(h.matches.grams||[]).map(g=> g.label+':'+g.grams+'g').join('|')
]);
}
const csv = rows.map(r => r.map(cell => '"'+String(cell).replace(/"/g,'""')+'"').join(',')).join('\\n');
const blob = new Blob([csv], {type:'text/csv'});
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url; a.download = 'scan-history.csv'; document.body.appendChild(a); a.click(); a.remove();
URL.revokeObjectURL(url);
});

// ----------------------------
// Utilities
// ----------------------------
function escapeRegex(s){ return s.replace(/[.*+?^${}()|[\\]\\\\]/g,'\\\\$&'); }
function escapeHtml(str){ return String(str).replace(/[&<>"']/g, function(m){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m]; }); }

// ----------------------------
// Initial load: set small intro text
// ----------------------------
ocrTextEl.textContent = 'No text recognized yet. Start camera or upload an image and click "Analyze OCR".';
status.textContent = 'Idle';

// ----------------------------
// Accessibility: keyboard shortcuts
// ----------------------------
window.addEventListener('keydown', (e)=>{
if (e.key === 'c') captureBtn.click();
if (e.key === 's') startCameraBtn.click();
if (e.key === 'p') analyzeBtn.click();
});

})();
</script>
</body>
</html>